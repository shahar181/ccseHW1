from flask import Flask, request, jsonify
# import google.generativeai as genai
import os
from book import Book
from books import Books


app = Flask(__name__)

# A dictionary of legal genres 
GENRE_LIST = ["Fiction", "Children", "Biography", "Science",
                "Science Fiction", "Fantasy", "Other"]

# Books object
books = Books()

# a dict with key 'id',
# 'id' is a JSON with 4 fields:
# 'values' - array of integers in range 1-5
# 'average' - number, floating point two decimal, average of values
# 'title' - STRING. 'id' - STRING.
# Hence the POST request on /ratings is not allowed.
# One cannot issue a DELETE request on /ratings/{id}.
# One also cannot perform a PUT request on /ratings/{id}.
ratings = {}

# is a JSON array of items. Each item in the array is a
# JSON structure with 3 fields:
# ‘id’ is a JSON string giving the id of a book.
# ‘title’ is the name of the book.
# ‘average’ is a float giving the average rating for that book.
# Constraints: (1) The books in the arrayhave the top scores out
# of all the books.
# (2) Every book in ‘top’ must have at least 3 ratings. 
# (3) ‘top’ contains all the books that have the top 3 scores. 
# If, for example, 4 books have a perfect score of 5, 
# all 4 would be given
# Only the GET request can be performed on /top. 
# It returns theresource /top (a JSON array).
top = []

# handeling post /books/{id}
@app.post("/books/")
def post_book():
    # The following fields are provided in the POST request:
    # ‘title’, ‘ISBN’, and ‘genre’
    # The following fields are filled by the server:
    # ‘authors’, ‘publisher’, and ‘publishedDate' - Google Books API
    # 'language' - The OpenLibrary API
    # 'summary' - LLM (OpenAI / Google)
    # 'id' - STRING, UNIQUE generated by the server
    # Upon success, the POST request returns the status code 201 and
    # returns the string id for the newly created book record.
    # if Unsucceful:
    # 415 (Unsupported media type), if instead of receiving a JSON record on the
    # request, another media type is given, such as XML.
    # 422 (Unprocessable Content), if the server is unable to 
    # process the request due to errors such as missing fields,
    # incorrect field names, or genre is not one of the accepted
    # values, etc. Also return 422 if there already exists a
    # book in /book with this ISBN number.
    # 500 (Internal Server Error), if the calls to Google Books or to the LLM
    # returns an error (e.g., the service is not available), and an error message
    # “unable to connect to <service>” where <service> is either “Google” or
    # “Gemini” (or other LLM used).
    # the server will also automatically create 
    # a new /ratings/N entry. It will initially have its 
    # field ‘value’ contain 0 ratings, 
    # its field ‘average’ will be set to 0, 
    # and its ‘id’ will be the book’s id.
    
    if request.is_json:
        book = request.get_json()

        # Checking inout info
        if not (book.get('title') and book.get('ISBN') and book.get('genre')):
            return {"error": "Missing fields - request should include title, ISBN and genre"}, 422
        if not (book.get('genre') in GENRE_LIST):
            return {"error": "Genre is not of legal type"}, 422
        if (book.get('ISBN') in books): # TBD - create books object in main
            return {"error": "Same ISBN already exists"}, 422
        
        # Input info check OK, adding the book to Books.
        book_id = books.add_book(book.get('title'), book.get('ISBN'), book.get('genre'))

        # Checking for errors using remote services
        if (book_id == -1):
            return {"error": "Unable to connect to Google Books"}, 500
        if (book_id == -2):
            return {"error": "Unable to connect to OpenLibrary"}, 500
        if (book_id == -3):
            return {"error": "Unable to connect to Gemini"}, 500
        
        # Adding to ratings 
        # ratings.add_rating(book_id, 0) # TBD - def add_ratings(book_id, rating)     
        return book_id, 201
    return {"error": "Request must be JSON"}, 415
    pass

# handeling get /books/{id}
@app.get("/books/'{'id'}'")
def get_books_id():
    # The GET request, upon success, returns the status code 200 
    # and returns a JSON record of the requested resource.
    # if Unsucceful:
    # 404 (Not Found), if the {id} is not a recognized id.
    pass

# handeling DELETE /books/{id}
@app.delete("/books/'{'id'}'")
def delete_books_id():
    # The DELETE request, upon success, returns the status code 200 
    # and returns the id of the deleted resource.
    # if Unsucceful:
    # 404 (Not Found), if the {id} is not a recognized id.
    # When/books/{id} is deleted, the server automatically 
    # deletes /ratings/{id}.
    pass

# handeling PUT /books/{id}
@app.put("/books/'{'id'}'")
def put_books_id():
    # The PUT request provides a JSON payload of the resource’s fields 
    # Upon success it returns the status code 200 
    # and returns the id of the updated resource.
    # The PUT request provides all the fields of the book.
    # No invocation of Google Books API or other services
    # should be performed.
    # if Unsucceful:
    # 404 (Not Found), if the {id} is not a recognized id.
    # 422 (Unprocessable Content), if the server is unable to 
    # process the request due to errors such as missing fields,
    # incorrect field names, or genre is not one of the accepted
    # values, etc.
    # 415 (Unsupported media type), if instead of receiving a JSON record
    # on the request, another media type is given (such as XML).
    pass
    # if request.is_json:

# handeling get /books
@app.get("/books")
def get_books():
    # GET returns a JSON array (use jsonify()) of all records 
    # in the resource.
    # The order of the fields does not matter.
    # query strings for filtering - slide 19 in the PDF
    # Check if there are query parameters in the request
    if request.args:
        filtered_books = []
        # Iterate over each book in the 'books' list
        for book in books:
            # Check if the specified field and value match
            if all((book.get(field) == value) and field != ("summary" or "language") for field, value in request.args.items()):
                filtered_books.append(book)
            # Check if 'language contains <value>' query parameter is present
            elif "language" in request.args and "contains" in request.args.get("language"):
                language_value = request.args.get("language").split("contains")[1].strip()
                # Check if the language is contained in the book's languages
                if any(language_value in language for language in book.get("languages", [])):
                    filtered_books.append(book)
        return jsonify(filtered_books), 200
    else:
        return jsonify(books), 200
    pass

# handeling get /ratings
@app.get("/ratings")
def get_ratings():
    # returns a JSON array (use jsonify()), 
    # each element is a JSON conatining the
    # information /ratings/{id} for each book.
    # The GET request may also contain a query string 
    # of the form: id=<string>
    pass

# hangeling post /ratings/{id}/values
@app.post("/ratings/'{'id'}'/values")
def post_ratings_id_values():
    # a POST requestthat adds a new rating for the book 
    # of the given id.
    # POST request contains a JSON structure of the form:
    # {“value”: <integer>} where <integer> is in {1,2,3,4,5}.
    # The POST request returns the new average rating for the book.
    pass
    # if request.is_json:
    # if id in ratings

# handeling get /top
@app.get("/top")
def get_top():
    # returns the resource /top (a JSON array (use jsonify()).
    pass

if __name__ == '__main__':
    app.run